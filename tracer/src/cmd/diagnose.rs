use std::{
    collections::{HashMap, HashSet},
    path::PathBuf,
};

use anyhow::{anyhow, Context};
use clap::Parser;
use lazy_regex::regex_captures;
use traceconf::Level;
use tracer::Entry;
use tracing::{debug, error, info, trace, warn};

/// Reads trace files generated by `diagnose` in the FOSSA CLI repository.
#[derive(Debug, Clone, Parser)]
#[clap(version)]
pub struct Arguments {
    /// The file to read. Must be uncompressed and in ndjson format.
    trace_file_path: PathBuf,

    /// Specify this flag to cause a log statement on each file that was inspected.
    #[clap(long)]
    output_file_paths: bool,
}

/// Reads trace files generated by `diagnose` in the FOSSA CLI repository.
pub fn main(args: Arguments, report_trace_level: Level) -> anyhow::Result<()> {
    // Read traces from the file.
    let file = std::fs::read_to_string(&args.trace_file_path).context("read trace file")?;

    let mut root_device_id = String::new();
    let mut path_device_id = HashMap::new();
    let mut device_ids = HashSet::new();
    let mut fs_loops = HashMap::new();
    let mut file_not_found_paths = HashMap::new();
    let mut files = HashSet::new();
    let mut inspected_paths = HashSet::new();

    // This uses a lot of extraction from the generic "message" field.
    //
    // Ideally, the things we look for here would be in standardized fields,
    // but currently `diagnose` mostly uses the message field.
    //
    // Hopefully at some point we'll update diagnose with more standardized output,
    // in which case we'll need to update this to handle both cases.
    let deserializer = serde_json::Deserializer::from_str(&file).into_iter::<Entry>();
    for (index, entry) in deserializer.enumerate() {
        let entry = entry.map_err(|err| anyhow!("parse entry index {index}: {err:#}"))?;
        if let Entry::Log(entry) = entry {
            let message = entry.fields().message();
            let timestamp = entry.common().timestamp();
            let level = entry.common().level();
            let target = entry.common().target();

            if index % 100_000 == 0 {
                info!(index, "Reading...");
            }

            match level {
                Level::Info => info!(%timestamp, %level, target, "{message}"),
                Level::Error => error!(%timestamp, %level, target, "{message}"),
                Level::Warn => warn!(%timestamp, %level, target, "{message}"),
                level @ Level::Debug if report_trace_level <= level => {
                    debug!(%timestamp, %level, target, "{message}")
                }
                level @ traceconf::Level::Trace if report_trace_level <= level => {
                    trace!(%timestamp, %level, target, "{message}")
                }
                _ => {}
            }

            if let Some((_, path)) = regex_captures!("inspect: (.+)", message) {
                let path = PathBuf::from(path);
                for path in path.ancestors() {
                    path_device_id.insert(path.to_path_buf(), String::default());
                }
                inspected_paths.insert(path);
            }

            if let Some((_, path)) = regex_captures!(" on ([^:]+): .+ error 2", message) {
                let path = PathBuf::from(path);
                let closest_parent = path
                    .ancestors()
                    .find(|ancestor| path_device_id.contains_key(*ancestor))
                    .map(|ancestor| ancestor.to_path_buf());

                file_not_found_paths.insert(path, closest_parent);
            }

            if let Some((_, id)) = regex_captures!("device_id: ([0-9]+)", message) {
                let span = entry.common().span();
                if span["root"].as_str().is_some() {
                    root_device_id = id.to_owned();
                }

                if let Some(path) = span["entry"].as_str() {
                    for path in PathBuf::from(path).ancestors() {
                        // Only set the device_id for the device if not yet seen;
                        // once a path has been "claimed" by a device its descendents shouldn't be able to claim it.
                        path_device_id
                            .entry(path.to_path_buf())
                            .and_modify(|device_id| {
                                if device_id.is_empty() {
                                    *device_id = id.to_owned()
                                }
                            })
                            .or_insert_with(|| id.to_owned());
                    }
                }

                device_ids.insert(id.to_owned());
            }

            if message == "is_file: true" {
                let span = entry.common().span();
                if let Some(path) = span["entry"].as_str() {
                    files.insert(path.to_owned());

                    if args.output_file_paths {
                        info!(path, "inspected file");
                    }
                } else {
                    warn!(?entry, "file inspection without associated entry");
                }
            }

            let link_loop = regex_captures!("found: (.+) points .+ ancestor (.+)", message);
            if let Some((_, link, dest)) = link_loop {
                let link = PathBuf::from(link);
                let dest = PathBuf::from(dest);
                let closest_parent = link
                    .ancestors()
                    .find(|ancestor| path_device_id.contains_key(*ancestor))
                    .map(|ancestor| ancestor.to_path_buf());

                fs_loops.insert((link, dest), closest_parent);
            }
        }
    }

    info!("");
    info!("");
    info!("total files not found: {}", file_not_found_paths.len());

    info!("");
    info!("total FS loops: {}", fs_loops.len());
    for (link, dest) in fs_loops.keys() {
        match pathdiff::diff_paths(dest, link) {
            Some(rel) => info!("  fs loop: '{}' -> '{}'", link.display(), rel.display()),
            None => info!("  fs loop: '{}' -> '{}'", link.display(), dest.display()),
        }
    }

    info!("");
    info!("total device_ids observed: {}", device_ids.len());
    info!("  root scan device_id: {root_device_id}");
    for device_id in device_ids {
        info!("  device_id: {device_id}");

        let device_paths = path_device_id
            .iter()
            .filter_map(
                |(path, id)| {
                    if id == &device_id {
                        Some(path)
                    } else {
                        None
                    }
                },
            )
            .collect::<HashSet<_>>();

        let file_count = files.len();
        let entry_count = device_paths.len();
        let shortest_path = device_paths
            .iter()
            .filter(|path| inspected_paths.contains(**path))
            .min_by(|a, b| a.components().count().cmp(&b.components().count()))
            .map(|path| path.to_path_buf())
            .unwrap_or_default();
        let loop_count = fs_loops
            .iter()
            .filter_map(|(_, parent)| parent.as_ref())
            .filter(|parent| device_paths.contains(parent))
            .count();
        let not_found_count = file_not_found_paths
            .iter()
            .filter_map(|(_, parent)| parent.as_ref())
            .filter(|parent| device_paths.contains(parent))
            .count();

        info!("    file count    : {file_count}");
        info!("    entry count   : {entry_count}");
        info!("    FS loops      : {loop_count}");
        info!("    dirs not found: {not_found_count}");
        info!("    shortest dir  : '{}'", shortest_path.display());
    }

    Ok(())
}
